# kotlin


## Chapter 3 코틀린 기본 작성법

* ### 3.1.1 일반 파일과 클래스 파일
  * 일반 파일(File)과 클래스 파일(Class) 구분 X
  * 두 파일에 대한 차이는 없음
  * 굳이 둘을 구분하는 이유는 단순히 코드를 읽기 쉽게 하려는 의도

* ### 3.1.2 파일의 구성요소
  * 대부분 프로그래밍 언어와 비슷
  * 코틀린 파일에도 패키지를 선언할 수 있는데, 반드시 파일의 첫 줄에 선언해야함
  * 코틀린 파일은 클래스를 사용하지 않고 변수와 함수로만 구성가능
  * 모든 구성요소를 클래스로 묶지 않아도 되며, 변수나 함수를 클래스 외부에 선언가능

* ### 3.2 패키지
* ### 3.2.1 패키지 기본 개념
    * 패키지란 관련된 클래스들을 묶기 위한 물리적인 개념
    * 물리적인 개념 : 실제 클래스가 위치하는 폴더
    * 같은 패키지에 있으면 import문 생략
    * 이용하려는 클래스가 다른 패키지에 있다면 import문 명시적 선언해야함
  
* ### 3.2.2 가상 패키지
  * 코틀린에서는 패키지가 꼭 실제 물리적인 폴더와 같을 필요 X
  * 즉, 코틀린 파일이 있는 폴더와 다른 패키지명을 사용가능
  * 파일의 위치와 다른 패키지명을 사용하면, 컴파일 떄 클래스 파일의 위치는 코드에 선언한 패지키명의 폴더가 됨

* ### 3.2.3 변수/함수 임포트
  * 클래스로 선언하지 않은 변수나 함수는 외부에서 어떻게 이용?
    *  변수나 함수도 클래스처럼 그대로 임포트
  * 변수나 함수를 직접 임포트하여 이용할 수 있는 것은 클래스로 묶지 않은 변수와 함수를 최상위 레벨로 관리하기 때문
  * 즉, 패키지 내에 선언된 전역변수나 전역함수처럼 취급

* ### 3.2.4 기본 패키지
  * 별도의 import 구문 없이 사용가능(kotiln.* , kotlin.annotaion.*....)

* ### 3.2.5 이름 변경해서 임포트하기
  * 클래스를 임포트할 떄 이름을 바꾸어 다른 이름 사용가능
    * ```kotlin
      import java.text.SimpleDateFormat as MySimpleDateFormat
  

* ### 자바 vs 코틀린
  * 코틀린에서는 모든 구성요소가 클래스로 묶일 필요는 없다
  * 코틀린에서는 파일명으로 된 클래스를 선언하지 않아도 된다
  * 코틀린에서는 프로그램 코드에서 파일의 위치와 다른 패키지명을 사용가능
  * 자바에서 함수나 변수를 직접 임포트할 수 있는 기능이 있지만 코틀린과는 다름
    * 자바에서는 static으로 선언한 변수나 함수만 직접 임포트해서 사용가능
    * 코틀린에서는 static 예약어 자체가 없음


## Chapter 4 변수와 함수

* ### 4.1 변수 선언 및 초기화

* ### 4.1.1 변수 선언법 (val,var)
  * 변수는 val이나 var 키워드를 이용해 명시적 선언
  * Assign-once(Read-only)와 Mutable로 구분
  * Assign-once는 한번 초기화하면 더는 변경 X
  * Mutable은 언제든지 변경가능
  * 변수 선언시 변수명을 먼저 입력 후 콜론(:) 뒤에 타입 명시
  * 데이터 타입을 명시하지 않으면 `타입 추론`을 이용해 자동으로 타입 적용
  * val은 이후 값변경 X -> 읽기전용변수
  * var은 이후 값변경 O
  * 코틀린에서 변수는 프로퍼티(property)

* ### 4.1.2 변수 초기화
  * 변수 선언은 최상위(클래스 외부),클래스 내부, 함수 내부에서 가능
  * 자동 초기화 X, 코드에서 직접 초기화 
  * 함수 내부에서 변수 선언과 동시에 값을 초기화하지 않아도 에러발생 X
  * 하지만 변수를 이용하려면 반드시 초기화해야함
  * 최상위 레벨과 클래스 멤버변수들은 변수의 선언과 초기화를 동시에 해줘야함

* ### 4.1.3 null이 될 수 있는 변수와 null
  * 변수에 null 값을 대입할 떄 주의할 점
    * 명시적으로 null이 될 수 있는 (nullable)변수로 선언해야함
    * null을 대입할 수 있는 변수와 없는 변수로 구분됨
  * 변수를 선언할떄 초기에 null을 대입하고 이후 적절한 곳에서 값을 대입하고자 한다면
    * ```kotlin
      var nullableData2: String? = null
      
      nullableData2 = "hello"
    ? 기호로 null이 될 수 있음을 명시, 변수값을 변경해야 하므로 var로 선언
  
* ### 4.1.4 상수변수 선언 (const)
  * val로 선언한 변수의 초깃값을 직접 변경 X
  * val은 프로퍼티이기 때문에 해당 변수의 get() 함수를 통해 변경가능
  * 처음에 대입한 값을 변경할 수 없고 항상 초깃값만 반환하도록 보장하는 변수 (const를 사용해 변수를 선언)
    * const 제약사항
      * var 변수에는 사용 X
      * 클래스, 함수 내부에서는 사용X
      * 변수를 최상위 레벨로 선언하거나 object로 선언한 클래스에서만 사용가능
  

* ### 4.2 함수 사용법
* ### 4.2.1 함수 선언 (fun)
  * 형식
    * ```kotlin
      fun 함수명(매개변수명 : 타입) : 반환타입 {}
      ex) fun sum(a: Int, b:Int): Int {
            return a+b
        }
  * 함수를 선언할 때 매개변수 부분에는 var,val을 선언못함
  * 매개변수는 무조건 val로 적용됨
  * 의미없는 반환값이 없을 때는 Unit으로 명시 (생략가능)
  * 특정 함수 내에 선언된 함수는 지역변수와 비슷한 개념 -> 외부에서 호출 X
  * 함수 선언 시 단일 구문으로 값을 반환하는 함수라면 중괄호 생략가능 반환값도 생략가능

* ### 4.2.2 함수 오버로딩
  * 자바와 똑같음

* ### 기본 인수와 명명된 인수
  * 함수를 호출하면서 전달하는 값을 인수
  * 인수 값을 전달받는 함수의 변수를 매개변수
  * 기본인수 = 호출자가 인수를 명시하지 않아도 피호출자가 알아서 기본값을 적용하게함
    * ```kotlin
      fun sayHello(name: String?) {
        if(name == null){
            println("Hello!! kkang")
        }else {
            println("Heelo!!"+name)
        }
      
      해당 코드를
      
      fun sayHello(name: String = "kkang") {
        println("Heelo!!"+name)
      }

  * 매개변수가 여러개일땐 명명된 인수를 사용해야함
    * ```kotlin
      fun sayHello(name: String = "kkang",no:Int) {
        println("Heelo!!"+name)
      }
      
      sayHello(10) -> 에러
      sayHello("lee",20)
      sayHello(no=20)
      
  * 명명된 인수 = 인수를 대입할 매개변수의 이름을 지정하는 기법


* ### 4.2.4 중위 표현식 (infix)
  * A+B 구문에서 A와 B라는 피연산자 사이에 +라는 연산자를 놓을 떄 `중위 포현식을 사용했다`라고 표현
  * 중위 표현식은 fun 앞에 infix라는 예약어를 추가하면 됨
    * ```kotlin
      obj.infixFun(10)
      을 중위표현식으로 표현하면
      obj infixFun 10
      객체명 함수명 매개변수
      
      infix fun infixFun(a: Int) {
          println("infixFun call...")
      }

  * infix 제약사항
    * 클래스의 멤버 함수로 선언하거나 클래스의 확장함수일 때
    * 매개변수가 하나인 함수일 때
    

* ### 4.2.5 가변 인수 (vararg)
  * 매개변수가 많을때 작성하면 편함
  * 가변 인수를 포함하는 함수는 vararg라는 예약어를 이용하여 선언
  * ```kotlin
    fun <T> varargsFun(a1:Int,vararg array: T) {
    for(a in array) {
        println(a)
      }
    }
      
    fun main(args : Array<String>) {
     varargsFun(10,"hello","world") // 반드시 첫번째 인수로 Int타입의 데이터를 지정해야함
     varargsFun(10,20,false)
    }

* ### 4.2.6 재귀함수 (tailrec)
  * tailrec을 이용하면 소스코드가 자바로 변경될 때 재귀함수가 아닌 일반적인 반복문으로 변형
  * 즉, StackOverflowError의 부담감에서 벗어날 수 있음
  * tailrec 예약어 주의사항
    * tailrec 재귀함수에서 자신을 다시 호출하는 구문은 함수의 맨 마지막 작업으로 작성해야함
    * 즉, 함수의 맨 마지막 작업이 재귀호출 구문이여야함
    

* ### 자바 vs 코틀린
  * 코틀린에서는 const로 최상위 레벨에 상수변수를 선언한다
    * public static final int CONST_VAL = 10;
    * const val CONST_VAL = 10
  * 최상위 레벨로 선언되어 객체 멤버에 포함되지 않으며 const로 선언되어 상수변수가 됨

  * 코틀린의 final은 자바의 final과 다르다
    * 자바에서 상수변수를 정의할때 final을 쓰지만 코틀린에서는 아님
    * 코틀린에서는 val로 선언함

  * 코틀린은 변수값이 자동으로 초기화되지 않는다
  * 코틀린에서는 자바에서 제공하지 않는 함수의 다양한 이용 방법을 제공한다

## Chapter 5 데이터 타입

* ### 5.1 기초 데이터 타입

* ### 5.1.1 숫자 타입 (Int,Long,Short,Double,Float)
  * 코틀린에서 모든 것은 객체
  * 클래스로 타입을 명시하여 선언한 변수는 그 자체로 객체
  * ```kotlin
    val intData : Int = 10
    val result = intData.minus(5)

    fun main(args: Array<String>) {
      println(result)
    }

  * 문자는 숫자 타입이 아니며, 숫자 타입에 대한 자동 형변환을 제공 X
  * 숫자 타입에 값을 대입할 때 규칙
    * Decimals,Haxadecimals,Binaries 값 대입 가능
    * Long형은 값 뒤에 'L' 사용
    * 실수 기본형은 Double
    * 실수형은 10.0e2로도 표현 가능
    * Float 형은 값 뒤에 'f', 'F' 사용
  

* ### 5.1.2 논리,문자와 문자열 타입 (Boolean,char,String)
  * Boolean 타입은 true,false값을 표현
    * || -> 논리합
    * && -> 논리곱
    * ! -> 부정
  
  * Char은 문자를 표현하는 타입
    * Char타입은 Number타입으로 표현 X
    
  * String은 문자열을 표현하는 타입
    * 문자열은 str[i]로 접근할 수 있는 Char의 집합
    * "" -> escaped string
    * """ -> raw string
    * 전자는 \n으로 개행되지만, 후자는 키보드에서 입력한 엔터 등의 값이 문자열에 그대로 적용
    * 문자열 내에 데이터를 쉽게 포함하기 위한 포현식 
      * 변수는 $변수명
      * 표현식은 ${표현식}
      * ```kotlin
            fun sum(no:Int): Int {
              var sum = 0;
                for(i in 1..no) {
                    sum+=i;
                }
              return sum
            }

          fun main(args: Array<String>) {
              val name:String = "kkang"
             println("result: $name .. ${sum(10)}")
          }

* ### 5.1.3 Any 타입
  * 코틀린 클래스의 최상위 클래스
  * 특정 변수에 대입되는 타입을 예측할 수 없을 떄 유용하게 사용
  * 자바의 Object타입과 유사

* ### 5.1.4 null 허용 타입
  * ```kotlin
    fun parseInt(str: String): Int? {
      return str.toIntOrNull()
    }
  * toIntOrNull함수는 문자열을 Int타입으로 변형하여 반환하고 변형할 수 없다면 null을 반환하는 함수
  * null을 반환할 수 있으므로 Int?로 선언
  * Any타입도 예외없음 ex) val data: Any? = null 이라고 명시해야함

* ### 5.1.5 Any, Any? 타입
  * Any 타입은 Any? 타입에 대입 O
  * Any? 타입은 Any타입에 대입 X
  * Any?타입이 코틀린 최상위 타입 Any?(조상) Any(자손)
    * ```kotlin
      val myVal1:Any = 10
      val myVal2:Any? = myVal1
  
      val myVal3:Any? = 10
      //val myVal4:Any = myVal3
      val myVal5: Any = myVal3 as Any
  
      val myInt1:Int = 10
      val myInt2:Int? = myInt1
  
      val myInt3:Int? = 10
      //val myInt4:Int = myInt3
      val myInt5: Int = myInt3 as Int

* ### 5.1.6 Unit과 Nothing
  * Unit은 흔히 함수의 반환 구문이 없다는 것을 표현 (자바의 void)
  * Nothing은 의미 있는 데이터가 없다는 것을 명시적으로 선언하기 위해 사용하는 타입

* ### 5.1.7 타입 확인과 캐스팅 (is, !is)
  * 데이터 타입을 확인해야 할때 사용
  * is 연산자로 타입을 확인해서 타입이 맞으면 자동으로 캐스팅됨
  * 코틀린에서는 데이터 타입의 변환이 자동으로 이루어지지 않음
  * 기초 데이터 타입에 대한 자동 형변환을 제공 X
  * Int타입에 변수를 Double타입의 변수에 대입하려면 변수.toDouble()함수를 이용해야함
  * 코틀린에서 형 변환이 자동으로 이뤄지는 떄는 값의 형 변환임
  * val l = 1L + 3 // Long + Int -> Long
  * as 연산자는 클래스의 상하위 관계에서만 가능

* ### 5.2. 컬렉션 타입

* ### 5.2.1 배열
  * 배열을 만드는 가장 쉬운 방법 `arrayOf()`
  * 제네릭스를 이용한 배열의 타입제한 또는 `intArrayof()`이용
  * 또는 Array클래스를 직접 이용도 가능
  * Array클래스의 생성자
    * Array(size: Int, init: (Int)-> T)
    * ex) var array3 = Array(3,{i -> i*10})
    * 첫번쨰 매개변수는 배열의 크기
    * 두번째 매개변수는 배열 index값에 10을 곱해서 대입
    * ```kotlin
      var array4 = Array<Int>(3,{i->i*10})
      var array5 = IntArray(3,{i->i*10})
  * 배열을 정의할 때 크기만 지정하고 데이터는 대입하지 않는 빈 상태 정의방법
    * arrayOfNulls()
      *  val array2 = arrayOfNulls<Any>(3)
    * 배열 클래스에 초깃값을 빈 상태로 주기
      * val emptyArr = Array<String>(3,{""})

* ### 5.2.2 List,Set,Map
 
  ![KakaoTalk_20240624_213845317](https://github.com/KimGyungSik/kotlin/assets/139200972/00a25427-8ef5-4b3c-a526-fb1eacef4802)
  
![KakaoTalk_20240624_214046016](https://github.com/KimGyungSik/kotlin/assets/139200972/ef1d03fe-1828-4917-963e-560a359a6611)


  * 코틀린에서 컬렉션 타입의 클래스들은 가변클래스와 불변클래스로 구분됨
  * 가변 클래스 : 컬렉션 타입의 객체에 데이터를 변경하거나 추가할 수 있음
  * 불변 클래스 : 한 번 데이터 대입이 끝난 객체를 읽기 전용으로 이용하는 정도
  * List인터페이스로 표현되는 객체는 불변(size(),get()만 제공)
  * MutableList인터페이스로 표현되는 객체는 가변(추가로 add(), set()제공)
  * ArrayList클래스를 직접 이용시 가변 상태 
  * 자바의 List,Set,Map 사용가능

* ### 5.2.3 이터레이터 (Iterator)
  * 컬렉션 타입의 데이터를 순회하기 위한 인터페이스
  * List,Map,Set,Array 타입의 데이터 모두 Iterator타입의 객체로 변형가능
  * iterator() 함수 사용
  * Map객체는 next()함수에 의해 Map.Entry 타입으로 객체를 가져옴 


* ### 자바 vs 코틀린
  * 코틀린에서는 모든 것이 객체이다
    * 자바에서는 래퍼 클래스를 제공
    * ![KakaoTalk_20240624_220012017](https://github.com/KimGyungSik/kotlin/assets/139200972/0de81353-86fb-4639-af55-ee974608f93f)
  * 코틀린에서는 기초 데이터 타입에 대한 자동 캐스팅을 제공하지 않는다
  * 코틀린에는 switch-case 구문이 없다
  * 코틀린은 배열을 []로 선언하지 않으며 {}을 이용하여 초기화하지도 않는다
    * 모든 것이 객체이므로 val array:Array로 표현되며 초깃값을 대입할 떄도 arrayOf()등의 함수를 이용해야함


---

## Chapter 6 흐름 제어 구문과 연산자

* ### 6.1 조건문

* ### 6.1.1 if 표현식
  * if문이 표현식임
    * ```kotlin
      val result = if( a> 10) "hello" else "world"

  * if문을 표현식으로 작성하면 else문 생략 X
  * if문을 중괄호 {}를 명시하여 여러 줄로 작성할 때 if표현식으로 발생하는 데이터는 맨 마지막에 작성
  * else if문은 얼마든지 추가할 수 있지만, else문은 생략 X
  * 표현식 : 특정 문장을 수행하여 결과값을 만들 때
  * 변수값에 대입할 수 있고 매개변수에 대입도 가능함
  * 코틀린에서는 if 문을 표현식으로 이용하여 변수값으로 혹은 함수 호출할 때 전달 인수로 지정할 수 있다는것

* ### 6.1.2 when 표현식
  * switch구문에서는 분기 조건을 정수로만 가능했지만, when에서는 다양한 타입의 데이터를 지정할 수 있음
  * 어느 조건과도 일치하지 않으면 else문을 실행 (생략가능)
  * when에 인수를 전달 안할시 if-else문의 형태로 이용됨
  * when은 if문과 마찬가지로 표현식임
  * 표현식 사용시 else문 생략 X, 하나의 조건에 여러 문장을 수행하고자 블록을 지정했으면 마지막 문장이 when이 반환하는 결과값이여야함
  * ch6.분기문.kt 참고

* ### 6.2 반복문
* ### 6.2.1 for 반복문 (in,indices)
  * 몇부터 몇까지 특정 범위를 표현할떄 숫자 사이에 점 두개(..)를 이용
  * for(i in 1..10) {} = 1부터 10까지 숫자를 1씩 증가하면서 변수 i에 대입하고 for의 {}부분을 10번 반복하라
  * 자바의 향상된 for문 
    * for(str in list)과 같음
  * 컬렉션 타입의 인덱스 값을 이용하고 싶으면 indices 프로퍼티를 사용
    * for(i in list.indices) {
          println(list[i]) }
    * list.indices == list.length
  
  * 컬렉션 타입의 인덱스와 값 모두 이용하고 싶으면 withIndex()라는 함수를 사용하여 인덱스($index)와 값($value)을 얻어온다
    * for((index,value) in list.withIndex()) { println("$index, $value") }
  * for(i in 1..100) {} = 100까지 포함
  * for(i in 1 until 100) {} = 100은 포함하지 않음
  * for(x in 2..10 step 2) {} = 2씩 증가
  * for(x in 10 downTo 1) {} = 숫자 감소


* ### 6.2.2 while 반복문 = 자바와 똑같음

* ### 6.2.3 break와 continue문, 그리고 라벨
  * break는 블록 {}을 벗어나기 위해 continue는 블록 {}의 맨 마지막 줄로 실행 흐름 이동
  * 만약 2중 for문을 사용할시 중첩된 반복문에서 안쪽 for문에 break,continue 등을 사용하면 자신을 감싼 가장 가까운 반복문에 영향을 줌
  * 가장 바깥쪽 for문을 벗어나고 싶으면 `라벨(Label)`을 사용

* ### 6.3.3 전개 연산자
  * 전개 연산자는 배열 데이터를 단순 나열할 떄 사용
  * array[0],array[1],array[2] => *array
  * 사용자 정의 함수에도 사용가능
    * some(*array) => some메서드의 매개변수에는 vararg가 추가되어있어야함
  * List도 가능하지만 배열 데이터로 변경해서 이용해야함 
    * some(*list3.toTypedArray())

* ### 6.3.6 논리 연산자
  * && 혹은 || 연산자의 왼쪽 결과값에 따라 오른쪽 피연산자로 작성한 구문이 실행되지 않을 수 있음
  * && 연산자는 왼쪽, 오른쪽 두 값이 모두 true일 때만 최종 결과값이 true이므로 왼쪽값이 true이면 오른쪽 값도 판단해야 하기 떄문에 함수호출
  * 하지만 왼쪽값이 false이면 오른쪽 함수 호출 X
  *


* ### 6.3.7 일치 연산자 
  * A==B : A와 B가 같은 값이면 true
  * A!=B : A와 B가 다른 값이면 true
  * A === B : A와 B가 같은 객체이면 true
  * A !== B : A와 B가 다른 객체이면 true
  * ==, === 연산은 같은 메모리를 참조하면  true, 아니면 false 즉 객체를 비교할땐 차이가 없음


---

## Chapter 8 프로퍼티

* ### 8.1 코틀린에서 프로퍼티 이용

* ### 8.1.1 프로퍼티란?
  * 클래스의 변수를 프로퍼티라 부름
  * var,val로 선언되는 변수들이 프로퍼티
  * 코틀린에서는 멤버변수가 아닌 프로퍼티 (자바에서 iv)
  * 프로퍼티 안에는 함수가 내장된 변수임
  * getter, setter가 내장되어 있음
  * 외부에서 프로퍼티를 이용할 떄 get(), set()가 호출 
  * var은 setter,getter 둘다 있지만 val은 getter만
  * 즉, 캡슐화해 정보은닉과 유지 보수성을 목적으로 프로퍼티를 사용

* ### 8.1.2 사용자 정의 프로퍼티
  * 개발자가 특정 작업(유효성 검사 등)에 프로퍼티 값을 이용하고자 한다면 getter/setter함수를 직접 정의해야함
  * 사용자 정의 프로퍼티.kt 참고
  * val로 선언한 프로퍼티는 get()함수를 정의하면 초깃값을 명시하지 않아도된다
  * var로 선언한 프로퍼티는 get()함수를 정의하더라도 초깃값을 명시해야한다
  * var로 선언된 프로퍼티는 변경 가능하므로, 초기값을 명시하지 않으면 컴파일러는 이 변수가 초기화되지 않은 상태로 사용될 가능성이 있다고 판단하여 오류를 발생시킵니다.
  
* ### 8.1.3 주 생성자와 프로퍼티
  * 지역변수는 프로퍼티가 아니다
  * 프로퍼티로 이용할 수 있는 변수는 어떤 블록 {}에도 포함되지 않는 최상위 레벨 변수와 클래스 내부에 선언한 멤버 변수이다
  * 생성자에 var,val로 선언한 변수에 get(),set()함수를 정의할 수 있음? 결론은 NO
  * 하지만 꼼수를 부리면, 주 생성자 프로퍼티 이용.kt 참고

* ### 8.2 프로퍼티 초기화
  * 프로퍼티는 선언과 동시에 초깃값을 대입해 초기화해야함
  * 초기에 null을 대입해 놓거나 아예 초기화 시점을 미루는 방법을 제공
* ### 8.2.1 초기화 블록에서 초기화 (init)
  * init 예약어로 명시하는 초기화 블록을 가질 수 있음
  * 클래스의 프로퍼티를 선언하면서 동시에 초기값을 대입하지 않고, 초기화 블록에서 프로퍼티를 초기화해 사용
  * 초기화블록 = 객체 생성과 동시에 실행되는 영역
* ### 8.2.2 null 허용으로 선언
  * 프로퍼티를 null 허용으로 선언해 null로 초기화하는 방법
  * 프로퍼티를 선언할 떄 null로 초기화한 후 실제 데이터로 값을 변경하는 방법
  
* ### 8.2.3 늦은 초기화 (lateinit)
  * 프로퍼티를 null 허용으로 선언하지 않고 프로퍼티 초기화를 미루는 방법도 있음
  * ```kotlin
    class User1 {
      lateinit var lateData: String
    }
  * 제약사항
    * lateinit는 var로 선언한 프로퍼티에만 사용할 수 있따
    * lateinit는 클래스 몸체에 선언한 프로퍼티에만 사용할 수 있다. 즉 주 생성자에서는 사용할 수 없다
    * lateinit는 사용자 정의 getter/setter를 사용하지 않은 프로퍼티에만 사용할 수 있다
    * null 허용 프로퍼티에느 사용할 수 없다
    * 기초 타입 프로퍼티에는 사용할 수 없다
    

* ### 8.2.4 초기화 미루기 (by lazy)
  * 프로퍼티의 초기화를 프로퍼티의 이용 시점으로 미루는 방법
  * 이를 위해 제공하는 것이 lazy, 일종의 실행 영역
  * 프로퍼티에 by lazy {}로 선언해 프로퍼티의 초기화를 lazy 영역에서 진행
  * lazy영역이 실행되는 시점은 프로퍼티가 이용되는 시점
  * 즉 프로퍼티를 선언하면서 초기화하는 것을 미루고 실제 사용하는 시점에 초기화
  * 제약사항
    * 호출 시점에 초기화 진행
    * val로 선언한 프로퍼티에만 사용가능
    * 클래스 몸체 이외에 최상위 레벨에서 사용 가능
    * 기초 타입에도 사용 가능
  * lazy.kt 참고
  * 프로퍼티를 선언할 떄 초기화하거나 null 허용으로 하면 되는데 굳이 lateintit, lazy 등으로 초기화 시점을 미루는 이유?
    * null을 대입하지 않는 프로퍼티에 단지 초기화 시점을 미루기 위해 null 허용으로 선언할 필요는 없음
    * null을 허용하지 않는 프로퍼티인데 처음에 값을 초기화 할수 없는 사례
      * 의존성 주입(DI) ... 스프링
      * 외부에서 값을 전달받으므로 선언 떄는 값을 명시 못함

* ### 8.3 프로퍼티 값 변경 감지
  * 코틀린에서는 프로퍼티 값이 변경되는 순간, 개발자가 준비한 코드를 실행할 수 있음
  * observable.kt 참고

* ### 자바 vs 코틀린
  * 코틀린에서는 필드를 제공하지 않는다
  * 자바에서는 필드 : 단지 변수
    * 코틀린에서는 프로퍼티 : getter/setter함수가 포함되어 있는 변수
---

## Chapter 9 상속

* ### 9.1 코틀린에서의 상속

* ### 9.1.1 Any 클래스
  * 모든 클래스는 Any 클래스를 상속받음
  * 하지만 java의 Object클래스와는 다름 / equals(), toString() 이외에 제공 X

* ### 9.1.2 상속을 통한 클래스 정의
  * 일반 상속과 똑같음
  * 클래스 선언에 open으로 시작하면 상속을 허용한다는 뜻
  * 상속 허용 여부를 명시하지 않으면 기본으로 final이 적용됨
  * 코틀린에서 상속 관계는 표현은 콜론( : )을 이용 / class Rect : Shape() {}
  
* ### 9.2 오버라이드
  * 상위 클래스에 정의된 프로퍼티나 함수를 하위 클래스에서 재정의하는 것을 말함
  * 함수 선언에도 명시적으로 open 예약어를 추가해야함
  * 재정의 허용 여부를 결정하는 기본값은 final이며, 이때 하위 클래스는에서 재정의할 수 없음
  * final 클래스 : 이 클래스를 상속받아 하위 클래스 작성금지
  * final 함수 : 이 함수를 하위 클래스에서 재정의 금지
  * final 프로퍼티 : 프로퍼티 재정의 금지

* ### 9.2.2 override 예약어
  * 하위 클래스에서 상속받은 상위 클래스의 함수를 재정의할 때 사용
  * override 예약어로 정의한 함수는 자동으로 open상태가 됨
  * 즉 override를 추가한 함수는 open을 추가하지 않아도 다시 하위 클래스에서 재정의할 수 있다는 의미
  * 하위 클래스에서 재정의하지 못하도록 막는 방법?
    * final 예약어를 이용 -> final override fun print() { ...}
  
* ### 9.2.3 프로퍼티 오버라이드
  * 함수의 오버라이드와 같은 개념
  * 함수와 마찬가지로 상위 클래스에서 open 예약어로 명시해 재정의를 허용하고 하위 클래스에서 override 예약어로 재정의한 것이라고 명시해야함
  * 제약사항
    * 상위 클래스의 프로퍼티와 이름, 타입이 모두 같아야함
    * 상위 클래스에 val로 선언된 프로퍼티는 하위에서 val,var로 재정의 가능
    * 상위에서 var로 선언된 프로퍼티는 하위에서 var로 재정의 가능(val로는 불가)
    * 상위에서 null 허용으로 선언된 경우 하위에서 null불허로 재정의 가능
    * 상위에서 null 불허로 선언된 경우 하위에서 null 허용으로 재정의 불가
    * override 예약어는 open을 내장하는 개념
    * 똑같이 프로퍼티도 final 명시하면 오버라이드 불가
    
* ### 9.2.4 상위 클래스 멤버 접근 (super)
  * 상위 클래스에 정의한 멤버도 함께 이용할때가 있음
  * super를 이용하여 상위 클래스 멤버 호출

* ### 9.3 상속과 생성자

* ### 9.3.1 상위 클래스 생성자 호출
  *  모든 클래스에는 생성자가 최소 하나 이상 선언되어 있어야 함
  * 하위 클래스의 객체를 생성할 때 어떤 식으로든 상위 클래스의 생성자는 무조건 실행되어야함
  * 상위 클래스의 생성자는 반드시 호출되어야 함
  * 즉, 하위 클래스 생성자에는 상위 클래스의 생성자를 매개변수 정보에 맞게 호출하는 구문이 있어야함
  * 1. 하위 클래스에 주 생성자가 선언된 경우
      * 하위 클래스의 객체가 생성될 떄 상위 클래스의 생성자가 호출됨
  * 2. 하위 클래스에 보조 생성자만 선언된 경우
      * 보조 생성자에서 상위 클래스의 생성자를 직접 super()로 연결할 수 있음
  * 생성자 간의 규칙
    * 클래스의 주 생성자가 선언되어 있다면 해당 클래스의 보조 생성자에서는 주 생성자와 연결하기 위한 this()구문이 추가되어야 한다
    * 객체 생성 시 어떤 식으로든 상위 클래스의 생성자는 호출되어야 한다
    
* ### 9.3.2 상하위 생성자의 수행 흐름
  * 생성자의 수행 흐름.kt 참고
  * 순서
    * this() 혹은 super()에 의한 다른 생성자 호출
    * init 블록 호출
    * 생성자의 영역 실행
    * 즉, 상위 init 블록 -> 상위 생성자 -> 하위 init 블록 -> 하위 생성자
  
* ### 9.4 상속과 캐스팅
  * 기초 데이터 타입의 캐스팅과 같이 자동 형변환이 안되며 함수를 이용해야함
* ### 9.4.1 스마트 캐스팅
  *  개발자가 코드에서 명시적으로 캐스팅을 선언하지 않아도 자동으로 캐스팅 되는것
  * is 예약어 이용시 타입 확인 가능
  * Any 타입은 연산을 할 수 없음 근데 data is Int 구문에 의해 자동 형변환이 이루어진 것
  * is 연산자에 의한 스마트 캐스팅은 기초 데이터 타입에만 적용되지 않음
  * 하위 타입의 객체를 상위 타입에 대입하는 것은 스마트 캐스팅이 일어나는데 반대는 에러
  
* ### 9.4.2 as를 이용한 캐스팅
  * 상속 관계에 있는 객체를 명시적으로 캐스팅 할 떄는 as를 이용함
  * 형식 `객체 as 타입`
    * 하위 타입 -> 상위 타입 -> 하위 타입
      * ```kotlin
        val obj3:Super = Sub1()
        val obj4:Sub1 = obj3 as Sub1
        obj4.superFun()
        obj4.subFun1()
    * 상위 타입의 객체를 하위 타입에 대입할 때는 스마트 캐스팅이 안되므로 as를 이용해 명시적으로 캐스팅해줘야함
    * 상위 타입 -> 하위 타입
      * ```kotlin
        val obj5:Sub = Super() as Sub1 -> 런타임 에러
        obj5.subFun1()
    * 하위 타입 -> 하위 타입
      * 같은 상위 클래스를 상속받은 두 개의 하위 클래스 간의 캐스팅
      * 역시 런타임 에러가 난다
    * 결론은 하위 타입 -> 상위 타입 -> 하위 타입으로 변환할 떄만 정상적으로 캐스팅됨
    
* ### 9.4.3 null 허용 객체의 캐스팅 (as?)
  * null 허용 객체 캐스팅
    * ```kotlin
      val obj7: Super? = Sub1()
      val obj8: Sub1 = obj7 as Sub1
  * null 허용 캐스팅 에러
    * ```kotlin
      val obj7: Super? = null
      val obj8: Sub1 = obj7 as Sub1 ---> 런타임 에러
  * as?에 의한 캐스팅
    * ```kotlin
      val obj7: Super? = null
      val obj8: Sub1? = obj7 as? Sub1
  * as?는 캐스팅 대상이 정상적인 객체이면 캐스팅을 진행, null이 대입되어 있으면 캐스팅을 진행하지 않고 null 반환
  * 캐스팅 받는 객체도 null허용으로 선언해야함

* ### 9.5 접근 제한자
* ### 9.5.1 접근 제한자란?
  * 외부의 접근을 적절하게 제어하려는 의도
  * 접근 제한자는 클래스,인터페이스,생성자,함수,프로퍼티 선언부에 추가 가능
  * 코틀린에서 제공하는 접근 제한자는 public, internal, protected, private 4가지

* ### 9.5.2 접근 제한자와 접근 범위
  * 프로퍼티와 함수를 최상위 레벨에 작성한다는 것 = 클래스에 멤버로 포함하지 않고 코틀린 파일에 정의 하는것
  * public : (Default)만약 접근 제한자를 명시하지 않으면 자동으로 public 적용. 접근 제한이 없다는 의미
  * private : (최상위)같은 파일 내에서만 접근 가능 / (클래스) 같은 클래스내에서만 접근가능
  * internal : (최상위)같은 모듈 내에서만 접근 가능 / (클래스) 같은 모듈에 선언된 클래스에서만 접근가능
    * 모듈?
    * an IntelliJ IDEA module : IntellJ 내에서의 모듈
    * a Maven project : 메이븐에서의 프로젝트 단위
    * a Gradel source set: 그레이들에서의 프로젝트 단위
  * protected : (최상위)최상위 레벨에서는 사용 불가능 / (클래스) 같은클래스||하위클래스 접근가능

* ### 9.5.3 프로퍼티와 생성자의 접근 제한
  * get()함수의 접근 제한자는 프로퍼티의 접근 제한자와 항상 같다
  * set()함수의 접근 제한자는 프로퍼티의 접근 제한자와 다르게 설정할 수 있지만, 접근 범위를 넓혀서 설정할 수는 없다
  * public > protected/internal > private
  * 주 생성자, 보조 생성자 모두 접근 제한자를 지정할 수 있음
  * 생성자는 protected로 지정할 수 없음
    * 주 생성자에 접근 제한자를 지정하려면 constructor키워드를 함께 써줘야함
      * ```kotlin
        class ConstructorVisbiclity private constructor(name:String) {
          val obj = ConstructorVisbiclity("kim")
          public constructor(name:String,no:Int): this(name){}
        }
    * private로 선언한 주 생성자는 클래스 내부에서만 호출가능

* ### 9.5.4 상속 관계와 접근 제한자
  * open과 private는 함께 사용할 수 없음 => 모순임
    * open : 하위 클래스에서 오버라이드를 허용하는 예약어, private로 선언한 함수와 프로퍼티는 해당 클래스 내에서만 접근가능 == 이치가 안맞음
  * 하위 클래스에서 상위 멤버를 오버라이드할 때 접근 범위를 줄일 수 없음 => 자바 오버라이드 규칙과 똑같음
  * open으로 선언한 함수와 프로퍼티에 private 접근 제한자 지정 X
  
* ### 자바 vs 코틀린
  * 코틀린에서 상속은 자바와 다른 부분이 있다
    * 코틀린의 기본 상위 클래스는 Object가 아니라 Any
    * 상속 관계 선언시 extends예약어를 사용하지 않고 콜론(:)을 이용해 타입 표현으로 상속 관계 표현
    * 코틀린의 클래스,변수,함수는 기본적으로 final이 적용되어 상속이나 오버라이딩이 불가능하며 상속이나 오버라이딩을 허용하려면 open으로 선언해야한다
    * 코틀린에서 객체를 명시적으로 캐스팅하려면 as를 이용
  * 코틀린의 기본 접근 제한자는 public이다
  
---

## Chapter 10 추상클래스와 인터페이스

* ### 10.1 추상 클래스

* ### 10.1.1 추상 클래스 선언 (abstract)
  * 프로퍼티 또한 추상형으로 만들 수 있음
  * 추상 프로퍼티 : 선언부만 있는 프로퍼티
  * 
  






 